#!/usr/bin/env python3
"""
Environment Variable Template Manager
Manages .env file templates and validates environment configurations
"""

import os
import sys
import argparse
import logging
from pathlib import Path
from typing import Dict, List, Optional
from dataclasses import dataclass

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s',
    datefmt='%H:%M:%S'
)
logger = logging.getLogger(__name__)


@dataclass
class EnvVariable:
    """Represents an environment variable"""
    name: str
    description: str
    required: bool = True
    default_value: Optional[str] = None
    example: Optional[str] = None
    sensitive: bool = False


class EnvTemplateManager:
    """Manages environment variable templates"""
    
    def __init__(self, template_dir: str = "templates"):
        self.template_dir = Path(template_dir)
        self.template_dir.mkdir(exist_ok=True)
        self.standard_vars = self._define_standard_variables()
    
    def _define_standard_variables(self) -> List[EnvVariable]:
        """Define standard environment variables"""
        return [
            # Application
            EnvVariable("APP_ENV", "Application environment", required=True, example="development|staging|production"),
            EnvVariable("APP_NAME", "Application name", required=True, example="my-app"),
            EnvVariable("APP_PORT", "Application port", required=False, default_value="8000", example="8000"),
            EnvVariable("APP_HOST", "Application host", required=False, default_value="0.0.0.0", example="0.0.0.0"),
            
            # Database
            EnvVariable("DATABASE_URL", "Database connection URL", required=True, example="postgresql://user:pass@localhost:5432/dbname", sensitive=True),
            EnvVariable("DB_POOL_SIZE", "Database connection pool size", required=False, default_value="10", example="10"),
            
            # Redis
            EnvVariable("REDIS_URL", "Redis connection URL", required=False, example="redis://localhost:6379/0"),
            
            # AWS
            EnvVariable("AWS_REGION", "AWS region", required=False, default_value="us-east-1", example="us-east-1"),
            EnvVariable("AWS_ACCESS_KEY_ID", "AWS access key", required=False, example="AKIA...", sensitive=True),
            EnvVariable("AWS_SECRET_ACCESS_KEY", "AWS secret key", required=False, example="wJalrX...", sensitive=True),
            
            # Monitoring
            EnvVariable("SENTRY_DSN", "Sentry error tracking DSN", required=False, example="https://example@sentry.io/123", sensitive=True),
            EnvVariable("LOG_LEVEL", "Application log level", required=False, default_value="INFO", example="DEBUG|INFO|WARNING|ERROR"),
            
            # Security
            EnvVariable("SECRET_KEY", "Application secret key", required=True, example="your-secret-key-here", sensitive=True),
            EnvVariable("JWT_SECRET", "JWT signing secret", required=False, example="jwt-secret-key", sensitive=True),
            
            # Email
            EnvVariable("SMTP_HOST", "SMTP server host", required=False, example="smtp.gmail.com"),
            EnvVariable("SMTP_PORT", "SMTP server port", required=False, default_value="587", example="587"),
            EnvVariable("SMTP_USER", "SMTP username", required=False, example="user@example.com"),
            EnvVariable("SMTP_PASSWORD", "SMTP password", required=False, example="password", sensitive=True),
        ]
    
    def generate_template(self, output_path: Optional[str] = None) -> str:
        """Generate .env template file"""
        output_path = Path(output_path) if output_path else self.template_dir / ".env.template"
        logger.info(f"Generating template â†’ {output_path}")
        
        content = self._build_template_content()
        output_path.parent.mkdir(parents=True, exist_ok=True)
        output_path.write_text(content)
        logger.info(f"Template generated: {output_path}")
        return str(output_path)
    
    def _build_template_content(self) -> str:
        """Build rich template with categories and metadata"""
        lines = [
            "# Environment Configuration Template",
            "# Copy to .env and fill in your values",
            "# NEVER commit .env to version control!",
            "",
            f"# Generated by: {Path(__file__).name}",
            "",
        ]
        
        categories = {
            "Application": ["APP_", "LOG_"],
            "Database": ["DATABASE_", "DB_"],
            "Cache": ["REDIS_"],
            "AWS": ["AWS_"],
            "Monitoring": ["SENTRY_"],
            "Security": ["SECRET_", "JWT_"],
            "Email": ["SMTP_"],
        }
        
        for category, prefixes in categories.items():
            vars_in_cat = [v for v in self.standard_vars if any(v.name.startswith(p) for p in prefixes)]
            if not vars_in_cat:
                continue
                
            lines.append(f"# {category}")
            lines.append("#" + "=" * 50)
            lines.append("")
            
            for var in vars_in_cat:
                lines.append(f"# {var.description}")
                lines.append(f"# Required: {'Yes' if var.required else 'No'}")
                if var.default_value:
                    lines.append(f"# Default: {var.default_value}")
                if var.example:
                    lines.append(f"# Example: {var.example}")
                if var.sensitive:
                    lines.append("# WARNING: Sensitive: Do not expose")
                
                value = var.default_value or ""
                lines.append(f"{var.name}={value}")
                lines.append("")
        
        lines.extend([
            "# Custom Variables",
            "#" + "=" * 50,
            "# Add your own below",
            "",
        ])
        
        return "\n".join(lines)
    
    def validate_env_file(self, env_path: str) -> Dict:
        """Validate .env file against template"""
        path = Path(env_path)
        if not path.exists():
            logger.error(f"File not found: {env_path}")
            return {"valid": False, "errors": ["File not found"]}
        
        env_vars = self._parse_env_file(path)
        errors, warnings, missing = [], [], []
        
        for var in self.standard_vars:
            if var.required and var.name not in env_vars:
                missing.append(var.name)
            elif var.required and var.name in env_vars:
                val = env_vars[var.name].strip()
                if not val:
                    errors.append(f"{var.name} is required but empty")
        
        for name, val in env_vars.items():
            if val in ["YOUR_VALUE_HERE", "CHANGE_ME", "TODO", ""]:
                warnings.append(f"{name} has placeholder/empty value")
            if any(v.name == name and v.sensitive for v in self.standard_vars):
                if len(val) < 12:
                    warnings.append(f"{name} is sensitive but too short (<12 chars)")
        
        result = {
            "valid": len(errors) == 0 and len(missing) == 0,
            "errors": errors,
            "warnings": warnings,
            "missing_required": missing,
            "total_vars": len(env_vars),
        }
        
        self._print_validation_result(result)
        return result
    
    def _parse_env_file(self, path: Path) -> Dict[str, str]:
        """Parse .env file safely"""
        env = {}
        with open(path, 'r') as f:
            for line in f:
                line = line.strip()
                if not line or line.startswith('#') or '=' not in line:
                    continue
                key, val = line.split('=', 1)
                env[key.strip()] = val.strip().strip('"\'')
        return env
    
    def _print_validation_result(self, result: Dict):
        """Pretty print validation"""
        print("\n" + "="*60)
        print("ENV VALIDATION RESULT")
        print("="*60)
        print(f"Valid: {'YES' if result['valid'] else 'NO'}")
        print(f"Total vars: {result['total_vars']}")
        
        if result["missing_required"]:
            print(f"\nMISSING ({len(result['missing_required'])}):")
            for v in result["missing_required"]:
                print(f"  - {v}")
        
        if result["errors"]:
            print(f"\nERRORS ({len(result['errors'])}):")
            for e in result["errors"]:
                print(f"  - {e}")
        
        if result["warnings"]:
            print(f"\nWARNINGS ({len(result['warnings'])}):")
            for w in result["warnings"]:
                print(f"  - {w}")
        
        print("="*60 + "\n")
    
    def init_project(self, project_dir: str = "."):
        """Initialize project with .env + .gitignore"""
        root = Path(project_dir).resolve()
        logger.info(f"Initializing project at: {root}")
        
        # Generate template
        template_path = root / ".env.template"
        self.generate_template(str(template_path))
        
        # Create .env if missing
        env_path = root / ".env"
        if not env_path.exists():
            env_path.write_text(template_path.read_text())
            logger.info(f"Created: {env_path}")
        else:
            logger.warning(f".env already exists: {env_path}")
        
        # Update .gitignore
        self._update_gitignore(root / ".gitignore")
        
        print("\n" + "="*60)
        print("ENVIRONMENT INITIALIZED")
        print("="*60)
        print("Next steps:")
        print("1. Edit .env with real values")
        print("2. Run: python env_template.py --validate .env")
        print("3. Share .env.template with team")
        print("="*60 + "\n")
    
    def _update_gitignore(self, gitignore_path: Path):
        """Ensure .env is ignored"""
        entries = "\n# Environment files\n.env\n.env.*\n"
        if gitignore_path.exists():
            if ".env" not in gitignore_path.read_text():
                gitignore_path.write_text(gitignore_path.read_text() + entries)
                logger.info("Updated .gitignore")
        else:
            gitignore_path.write_text(entries)
            logger.info("Created .gitignore")


def main():
    parser = argparse.ArgumentParser(description="Env Template Manager")
    parser.add_argument('--init', action='store_true', help="Initialize project env")
    parser.add_argument('--generate', type=str, help="Generate template at path")
    parser.add_argument('--validate', type=str, help="Validate .env file")
    
    args = parser.parse_args()
    manager = EnvTemplateManager()
    
    if args.init:
        manager.init_project()
    elif args.generate:
        manager.generate_template(args.generate)
    elif args.validate:
        result = manager.validate_env_file(args.validate)
        sys.exit(0 if result["valid"] else 1)
    else:
        parser.print_help()


if __name__ == '__main__':
    main()